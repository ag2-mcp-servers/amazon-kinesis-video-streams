# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:17:43+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, SecretStr, conint, constr


class APIName(Enum):
    PUT_MEDIA = 'PUT_MEDIA'
    GET_MEDIA = 'GET_MEDIA'
    LIST_FRAGMENTS = 'LIST_FRAGMENTS'
    GET_MEDIA_FOR_FRAGMENT_LIST = 'GET_MEDIA_FOR_FRAGMENT_LIST'
    GET_HLS_STREAMING_SESSION_URL = 'GET_HLS_STREAMING_SESSION_URL'
    GET_DASH_STREAMING_SESSION_URL = 'GET_DASH_STREAMING_SESSION_URL'
    GET_CLIP = 'GET_CLIP'
    GET_IMAGES = 'GET_IMAGES'


class AccessDeniedException(RootModel[Any]):
    root: Any


class AccountChannelLimitExceededException(RootModel[Any]):
    root: Any


class AccountStreamLimitExceededException(RootModel[Any]):
    root: Any


class ChannelName(
    RootModel[constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)]
):
    root: constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)


class ChannelProtocol(Enum):
    WSS = 'WSS'
    HTTPS = 'HTTPS'
    WEBRTC = 'WEBRTC'


class ChannelRole(Enum):
    MASTER = 'MASTER'
    VIEWER = 'VIEWER'


class ChannelType(Enum):
    SINGLE_MASTER = 'SINGLE_MASTER'
    FULL_MESH = 'FULL_MESH'


class ClientLimitExceededException(RootModel[Any]):
    root: Any


class ComparisonOperator(Enum):
    BEGINS_WITH = 'BEGINS_WITH'


class ConfigurationStatus(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class DataEndpoint(RootModel[str]):
    root: str


class DataRetentionChangeInHours(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class DataRetentionInHours(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class DeleteAfterUpload(RootModel[bool]):
    root: bool


class DeleteSignalingChannelOutput(BaseModel):
    pass


class DeleteStreamOutput(BaseModel):
    pass


class DestinationRegion(
    RootModel[
        constr(pattern=r'^[a-z]+(-[a-z]+)?-[a-z]+-[0-9]$', min_length=9, max_length=14)
    ]
):
    root: constr(
        pattern=r'^[a-z]+(-[a-z]+)?-[a-z]+-[0-9]$', min_length=9, max_length=14
    )


class DestinationUri(
    RootModel[
        constr(
            pattern=r'^[a-zA-Z_0-9]+:(//)?([^/]+)/?([^*]*)$',
            min_length=1,
            max_length=255,
        )
    ]
):
    root: constr(
        pattern=r'^[a-zA-Z_0-9]+:(//)?([^/]+)/?([^*]*)$', min_length=1, max_length=255
    )


class DeviceName(
    RootModel[constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=128)]
):
    root: constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=128)


class DeviceStreamLimitExceededException(RootModel[Any]):
    root: Any


class DurationInSeconds(RootModel[conint(ge=60, le=3600)]):
    root: conint(ge=60, le=3600)


class EdgeRetentionInHours(RootModel[conint(ge=1, le=720)]):
    root: conint(ge=1, le=720)


class FailedStatusDetails(RootModel[str]):
    root: str


class Format(Enum):
    JPEG = 'JPEG'
    PNG = 'PNG'


class FormatConfigKey(Enum):
    JPEGQuality = 'JPEGQuality'


class FormatConfigValue(
    RootModel[constr(pattern=r'^[a-zA-Z_0-9]+', min_length=0, max_length=256)]
):
    root: constr(pattern=r'^[a-zA-Z_0-9]+', min_length=0, max_length=256)


class GetDataEndpointOutput(BaseModel):
    DataEndpoint_1: Optional[DataEndpoint] = Field(None, alias='DataEndpoint')


class HeightPixels(RootModel[conint(ge=1, le=2160)]):
    root: conint(ge=1, le=2160)


class HubDeviceArn(
    RootModel[
        constr(
            pattern=r'arn:[a-z\d-]+:iot:[a-z0-9-]+:[0-9]+:thing/[a-zA-Z0-9_.-]+',
            min_length=1,
            max_length=1024,
        )
    ]
):
    root: constr(
        pattern=r'arn:[a-z\d-]+:iot:[a-z0-9-]+:[0-9]+:thing/[a-zA-Z0-9_.-]+',
        min_length=1,
        max_length=1024,
    )


class ImageGenerationDestinationConfig(BaseModel):
    DestinationRegion_1: DestinationRegion = Field(..., alias='DestinationRegion')
    Uri: DestinationUri


class ImageSelectorType(Enum):
    SERVER_TIMESTAMP = 'SERVER_TIMESTAMP'
    PRODUCER_TIMESTAMP = 'PRODUCER_TIMESTAMP'


class InvalidArgumentException(RootModel[Any]):
    root: Any


class InvalidDeviceException(RootModel[Any]):
    root: Any


class InvalidResourceFormatException(RootModel[Any]):
    root: Any


class KmsKeyId(RootModel[constr(pattern=r'.+', min_length=1, max_length=2048)]):
    root: constr(pattern=r'.+', min_length=1, max_length=2048)


class ListOfProtocols(RootModel[List[ChannelProtocol]]):
    root: List[ChannelProtocol] = Field(..., max_length=5, min_length=1)


class ListStreamsInputLimit(RootModel[conint(ge=1, le=10000)]):
    root: conint(ge=1, le=10000)


class MappedResourceConfigurationListLimit(RootModel[conint(ge=1, le=1)]):
    root: conint(ge=1, le=1)


class MaxLocalMediaSizeInMB(RootModel[conint(ge=64, le=2000000)]):
    root: conint(ge=64, le=2000000)


class MediaStorageConfigurationStatus(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class MediaType(
    RootModel[
        constr(
            pattern=r'[\w\-\.\+]+/[\w\-\.\+]+(,[\w\-\.\+]+/[\w\-\.\+]+)*',
            min_length=1,
            max_length=128,
        )
    ]
):
    root: constr(
        pattern=r'[\w\-\.\+]+/[\w\-\.\+]+(,[\w\-\.\+]+/[\w\-\.\+]+)*',
        min_length=1,
        max_length=128,
    )


class MediaUriSecretArn(RootModel[SecretStr]):
    root: SecretStr


class MediaUriType(Enum):
    RTSP_URI = 'RTSP_URI'
    FILE_URI = 'FILE_URI'


class MessageTtlSeconds(RootModel[conint(ge=5, le=120)]):
    root: conint(ge=5, le=120)


class NextToken(
    RootModel[constr(pattern=r'[a-zA-Z0-9+/=]*', min_length=0, max_length=512)]
):
    root: constr(pattern=r'[a-zA-Z0-9+/=]*', min_length=0, max_length=512)


class NoDataRetentionException(RootModel[Any]):
    root: Any


class NotAuthorizedException(RootModel[Any]):
    root: Any


class NotificationDestinationConfig(BaseModel):
    Uri: DestinationUri


class ResourceARN(
    RootModel[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ]
):
    root: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    )


class ResourceEndpoint(RootModel[str]):
    root: str


class ResourceEndpointListItem(BaseModel):
    Protocol: Optional[ChannelProtocol] = None
    ResourceEndpoint_1: Optional[ResourceEndpoint] = Field(
        None, alias='ResourceEndpoint'
    )


class ResourceInUseException(RootModel[Any]):
    root: Any


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class SamplingInterval(RootModel[conint(ge=3000, le=20000)]):
    root: conint(ge=3000, le=20000)


class ScheduleExpression(
    RootModel[constr(pattern=r'[^\n]{11,100}', min_length=11, max_length=100)]
):
    root: constr(pattern=r'[^\n]{11,100}', min_length=11, max_length=100)


class SingleMasterChannelEndpointConfiguration(BaseModel):
    Protocols: Optional[ListOfProtocols] = None
    Role: Optional[ChannelRole] = None


class SingleMasterConfiguration(BaseModel):
    MessageTtlSeconds_1: Optional[MessageTtlSeconds] = Field(
        None, alias='MessageTtlSeconds'
    )


class Status(Enum):
    CREATING = 'CREATING'
    ACTIVE = 'ACTIVE'
    UPDATING = 'UPDATING'
    DELETING = 'DELETING'


class StrategyOnFullSize(Enum):
    DELETE_OLDEST_MEDIA = 'DELETE_OLDEST_MEDIA'
    DENY_NEW_MEDIA = 'DENY_NEW_MEDIA'


class StreamEdgeConfigurationNotFoundException(RootModel[Any]):
    root: Any


class StreamName(
    RootModel[constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)]
):
    root: constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)


class StreamNameCondition(BaseModel):
    ComparisonOperator_1: Optional[ComparisonOperator] = Field(
        None, alias='ComparisonOperator'
    )
    ComparisonValue: Optional[StreamName] = None


class SyncStatus(Enum):
    SYNCING = 'SYNCING'
    ACKNOWLEDGED = 'ACKNOWLEDGED'
    IN_SYNC = 'IN_SYNC'
    SYNC_FAILED = 'SYNC_FAILED'
    DELETING = 'DELETING'
    DELETE_FAILED = 'DELETE_FAILED'


class TagKey(
    RootModel[
        constr(pattern=r'^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$', min_length=1, max_length=128)
    ]
):
    root: constr(
        pattern=r'^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$', min_length=1, max_length=128
    )


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class TagResourceOutput(BaseModel):
    pass


class TagStreamOutput(BaseModel):
    pass


class TagValue(
    RootModel[
        constr(pattern=r'[\p{L}\p{Z}\p{N}_.:/=+\-@]*', min_length=0, max_length=256)
    ]
):
    root: constr(pattern=r'[\p{L}\p{Z}\p{N}_.:/=+\-@]*', min_length=0, max_length=256)


class TagsPerResourceExceededLimitException(RootModel[Any]):
    root: Any


class Timestamp(RootModel[datetime]):
    root: datetime


class Type(RootModel[str]):
    root: str


class UntagResourceInput(BaseModel):
    ResourceARN_1: ResourceARN = Field(..., alias='ResourceARN')
    TagKeyList_1: TagKeyList = Field(..., alias='TagKeyList')


class UntagResourceOutput(BaseModel):
    pass


class UntagStreamInput(BaseModel):
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')
    TagKeyList_1: TagKeyList = Field(..., alias='TagKeyList')


class UntagStreamOutput(BaseModel):
    pass


class UpdateDataRetentionOperation(Enum):
    INCREASE_DATA_RETENTION = 'INCREASE_DATA_RETENTION'
    DECREASE_DATA_RETENTION = 'DECREASE_DATA_RETENTION'


class UpdateDataRetentionOutput(BaseModel):
    pass


class UpdateImageGenerationConfigurationOutput(BaseModel):
    pass


class UpdateMediaStorageConfigurationOutput(BaseModel):
    pass


class UpdateNotificationConfigurationOutput(BaseModel):
    pass


class UpdateSignalingChannelOutput(BaseModel):
    pass


class UpdateStreamOutput(BaseModel):
    pass


class Version(RootModel[constr(pattern=r'[a-zA-Z0-9]+', min_length=1, max_length=64)]):
    root: constr(pattern=r'[a-zA-Z0-9]+', min_length=1, max_length=64)


class VersionMismatchException(RootModel[Any]):
    root: Any


class WidthPixels(RootModel[conint(ge=1, le=3840)]):
    root: conint(ge=1, le=3840)


class ListTagsForResourcePostRequest(BaseModel):
    NextToken: Optional[
        constr(pattern=r'[a-zA-Z0-9+/=]*', min_length=0, max_length=512)
    ] = Field(
        None,
        description='If you specify this parameter and the result of a <code>ListTagsForResource</code> call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags. ',
    )
    ResourceARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the signaling channel for which you want to list tags.',
    )


class UntagResourcePostRequest(BaseModel):
    ResourceARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the signaling channel from which you want to remove tags.',
    )
    TagKeyList: List[TagKey] = Field(
        ...,
        description='A list of the keys of the tags that you want to remove.',
        max_length=50,
        min_length=1,
    )


class CreateStreamPostRequest(BaseModel):
    DataRetentionInHours: Optional[conint(ge=0)] = Field(
        None,
        description='<p>The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.</p> <p>The default value is 0, indicating that the stream does not persist data.</p> <p>When the <code>DataRetentionInHours</code> value is 0, consumers can still consume the fragments that remain in the service host buffer, which has a retention time limit of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the buffer when either limit is reached.</p>',
    )
    DeviceName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=128)
    ] = Field(
        None,
        description='<p>The name of the device that is writing to the stream. </p> <note> <p>In the current implementation, Kinesis Video Streams does not use this name.</p> </note>',
    )
    KmsKeyId: Optional[constr(pattern=r'.+', min_length=1, max_length=2048)] = Field(
        None,
        description='<p>The ID of the Key Management Service (KMS) key that you want Kinesis Video Streams to use to encrypt stream data.</p> <p>If no key ID is specified, the default, Kinesis Video-managed key (<code>aws/kinesisvideo</code>) is used.</p> <p> For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">DescribeKey</a>. </p>',
    )
    MediaType: Optional[
        constr(
            pattern=r'[\w\-\.\+]+/[\w\-\.\+]+(,[\w\-\.\+]+/[\w\-\.\+]+)*',
            min_length=1,
            max_length=128,
        )
    ] = Field(
        None,
        description='<p>The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">Media Types</a>. If you choose to specify the <code>MediaType</code>, see <a href="https://tools.ietf.org/html/rfc6838#section-4.2">Naming Requirements</a> for guidelines.</p> <p>Example valid values include "video/h264" and "video/h264,audio/aac".</p> <p>This parameter is optional; the default value is <code>null</code> (or empty in JSON).</p>',
    )
    StreamName: constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256) = (
        Field(
            ...,
            description='<p>A name for the stream that you are creating.</p> <p>The stream name is an identifier for the stream, and must be unique for each account and region.</p>',
        )
    )
    Tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).',
    )


class DeleteSignalingChannelPostRequest(BaseModel):
    ChannelARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the signaling channel that you want to delete.',
    )
    CurrentVersion: Optional[
        constr(pattern=r'[a-zA-Z0-9]+', min_length=1, max_length=64)
    ] = Field(
        None,
        description='The current version of the signaling channel that you want to delete. You can obtain the current version by invoking the <code>DescribeSignalingChannel</code> or <code>ListSignalingChannels</code> API operations.',
    )


class DeleteStreamPostRequest(BaseModel):
    CurrentVersion: Optional[
        constr(pattern=r'[a-zA-Z0-9]+', min_length=1, max_length=64)
    ] = Field(
        None,
        description='<p>Optional: The version of the stream that you want to delete. </p> <p>Specify the version as a safeguard to ensure that your are deleting the correct stream. To get the stream version, use the <code>DescribeStream</code> API.</p> <p>If not specified, only the <code>CreationTime</code> is checked before deleting the stream.</p>',
    )
    StreamARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the stream that you want to delete. ',
    )


class DescribeEdgeConfigurationPostRequest(BaseModel):
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the stream. Specify either the <code>StreamName</code>or the <code>StreamARN</code>.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream whose edge configuration you want to update. Specify either the <code>StreamName</code> or the <code>StreamARN</code>. ',
    )


class DescribeImageGenerationConfigurationPostRequest(BaseModel):
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the Kinesis video stream from which to retrieve the image generation configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream from which to retrieve the image generation configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>. ',
    )


class DescribeMappedResourceConfigurationPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=1)] = Field(
        None, description='The maximum number of results to return in the response.'
    )
    NextToken: Optional[
        constr(pattern=r'[a-zA-Z0-9+/=]*', min_length=0, max_length=512)
    ] = Field(
        None,
        description='The token to provide in your next request, to get another batch of results.',
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(None, description='The Amazon Resource Name (ARN) of the stream.')
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(None, description='The name of the stream.')


class DescribeMediaStorageConfigurationPostRequest(BaseModel):
    ChannelARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(None, description='The Amazon Resource Name (ARN) of the channel.')
    ChannelName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(None, description='The name of the channel.')


class DescribeNotificationConfigurationPostRequest(BaseModel):
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to retrieve the notification configuration. You must specify either the <code>StreamName</code> or the StreamARN.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream from which to retrieve the notification configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )


class DescribeSignalingChannelPostRequest(BaseModel):
    ChannelARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None, description='The ARN of the signaling channel that you want to describe.'
    )
    ChannelName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None, description='The name of the signaling channel that you want to describe.'
    )


class DescribeStreamPostRequest(BaseModel):
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(None, description='The Amazon Resource Name (ARN) of the stream.')
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(None, description='The name of the stream.')


class GetDataEndpointPostRequest(BaseModel):
    APIName_1: APIName = Field(
        ...,
        alias='APIName',
        description='The name of the API action for which to get an endpoint.',
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the stream that you want to get the endpoint for. You must specify either this parameter or a <code>StreamName</code> in the request. ',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream that you want to get the endpoint for. You must specify either this parameter or a <code>StreamARN</code> in the request.',
    )


class GetSignalingChannelEndpointPostRequest(BaseModel):
    ChannelARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the signalling channel for which you want to get an endpoint.',
    )
    SingleMasterChannelEndpointConfiguration_1: Optional[
        SingleMasterChannelEndpointConfiguration
    ] = Field(
        None,
        alias='SingleMasterChannelEndpointConfiguration',
        description='An object that contains the endpoint configuration for the <code>SINGLE_MASTER</code> channel type. ',
    )


class ChannelNameCondition(BaseModel):
    ComparisonOperator_1: Optional[ComparisonOperator] = Field(
        None, alias='ComparisonOperator'
    )
    ComparisonValue: Optional[ChannelName] = None


class ListSignalingChannelsPostRequest(BaseModel):
    ChannelNameCondition_1: Optional[ChannelNameCondition] = Field(
        None,
        alias='ChannelNameCondition',
        description='An optional input parameter for the <code>ListSignalingChannels</code> API. When this parameter is specified while invoking <code>ListSignalingChannels</code>, the API returns only the channels that satisfy a condition specified in <code>ChannelNameCondition</code>.',
    )
    MaxResults: Optional[conint(ge=1, le=10000)] = Field(
        None,
        description='The maximum number of channels to return in the response. The default is 500.',
    )
    NextToken: Optional[
        constr(pattern=r'[a-zA-Z0-9+/=]*', min_length=0, max_length=512)
    ] = Field(
        None,
        description='If you specify this parameter, when the result of a <code>ListSignalingChannels</code> operation is truncated, the call returns the <code>NextToken</code> in the response. To get another batch of channels, provide this token in your next request.',
    )


class ListStreamsPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=10000)] = Field(
        None,
        description='The maximum number of streams to return in the response. The default is 10,000.',
    )
    NextToken: Optional[
        constr(pattern=r'[a-zA-Z0-9+/=]*', min_length=0, max_length=512)
    ] = Field(
        None,
        description='If you specify this parameter, when the result of a <code>ListStreams</code> operation is truncated, the call returns the <code>NextToken</code> in the response. To get another batch of streams, provide this token in your next request.',
    )
    StreamNameCondition_1: Optional[StreamNameCondition] = Field(
        None,
        alias='StreamNameCondition',
        description='Specifies the condition that streams must satisfy to be returned when you list streams (see the <code>ListStreams</code> API). A condition has a comparison operation and a value. Currently, you can specify only the <code>BEGINS_WITH</code> operator, which finds streams whose names start with a given prefix. ',
    )


class ListTagsForStreamPostRequest(BaseModel):
    NextToken: Optional[
        constr(pattern=r'[a-zA-Z0-9+/=]*', min_length=0, max_length=512)
    ] = Field(
        None,
        description='If you specify this parameter and the result of a <code>ListTagsForStream</code> call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.',
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the stream that you want to list tags for.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None, description='The name of the stream that you want to list tags for.'
    )


class TagStreamPostRequest(BaseModel):
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the resource that you want to add the tag or tags to.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream that you want to add the tag or tags to.',
    )
    Tags: Dict[str, TagValue] = Field(
        ...,
        description='A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).',
    )


class UntagStreamPostRequest(BaseModel):
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the stream that you want to remove tags from.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None, description='The name of the stream that you want to remove tags from.'
    )
    TagKeyList: List[TagKey] = Field(
        ...,
        description='A list of the keys of the tags that you want to remove.',
        max_length=50,
        min_length=1,
    )


class Operation(Enum):
    INCREASE_DATA_RETENTION = 'INCREASE_DATA_RETENTION'
    DECREASE_DATA_RETENTION = 'DECREASE_DATA_RETENTION'


class UpdateDataRetentionPostRequest(BaseModel):
    CurrentVersion: constr(pattern=r'[a-zA-Z0-9]+', min_length=1, max_length=64) = (
        Field(
            ...,
            description='The version of the stream whose retention period you want to change. To get the version, call either the <code>DescribeStream</code> or the <code>ListStreams</code> API.',
        )
    )
    DataRetentionChangeInHours: conint(ge=1) = Field(
        ...,
        description='The retention period, in hours. The value you specify replaces the current value. The maximum value for this parameter is 87600 (ten years).',
    )
    Operation_1: Operation = Field(
        ...,
        alias='Operation',
        description='Indicates whether you want to increase or decrease the retention period.',
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the stream whose retention period you want to change.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream whose retention period you want to change.',
    )


class MediaStorageConfiguration1(BaseModel):
    Status: Optional[MediaStorageConfigurationStatus] = None
    StreamARN: Optional[ResourceARN] = None


class UpdateMediaStorageConfigurationPostRequest(BaseModel):
    ChannelARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(..., description='The Amazon Resource Name (ARN) of the channel.')
    MediaStorageConfiguration: MediaStorageConfiguration1 = Field(
        ...,
        description='A structure that encapsulates, or contains, the media storage configuration properties.',
    )


class NotificationConfiguration1(BaseModel):
    DestinationConfig: Optional[NotificationDestinationConfig] = None
    Status: Optional[ConfigurationStatus] = None


class UpdateNotificationConfigurationPostRequest(BaseModel):
    NotificationConfiguration: Optional[NotificationConfiguration1] = Field(
        None,
        description='The structure that contains the notification information for the KVS images delivery. If this parameter is null, the configuration will be deleted from the stream.',
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the notification configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream from which to update the notification configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )


class UpdateSignalingChannelPostRequest(BaseModel):
    ChannelARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the signaling channel that you want to update.',
    )
    CurrentVersion: constr(pattern=r'[a-zA-Z0-9]+', min_length=1, max_length=64) = (
        Field(
            ...,
            description='The current version of the signaling channel that you want to update.',
        )
    )
    SingleMasterConfiguration_1: Optional[SingleMasterConfiguration] = Field(
        None,
        alias='SingleMasterConfiguration',
        description='A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel type.',
    )


class UpdateStreamPostRequest(BaseModel):
    CurrentVersion: constr(pattern=r'[a-zA-Z0-9]+', min_length=1, max_length=64) = (
        Field(
            ...,
            description='The version of the stream whose metadata you want to update.',
        )
    )
    DeviceName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=128)
    ] = Field(
        None,
        description='<p>The name of the device that is writing to the stream. </p> <note> <p> In the current implementation, Kinesis Video Streams does not use this name. </p> </note>',
    )
    MediaType: Optional[
        constr(
            pattern=r'[\w\-\.\+]+/[\w\-\.\+]+(,[\w\-\.\+]+/[\w\-\.\+]+)*',
            min_length=1,
            max_length=128,
        )
    ] = Field(
        None,
        description='<p>The stream\'s media type. Use <code>MediaType</code> to specify the type of content that the stream contains to the consumers of the stream. For more information about media types, see <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">Media Types</a>. If you choose to specify the <code>MediaType</code>, see <a href="https://tools.ietf.org/html/rfc6838#section-4.2">Naming Requirements</a>.</p> <p>To play video on the console, you must specify the correct video type. For example, if the video in the stream is H.264, specify <code>video/h264</code> as the <code>MediaType</code>.</p>',
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None, description='The ARN of the stream whose metadata you want to update.'
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='<p>The name of the stream whose metadata you want to update.</p> <p>The stream name is an identifier for the stream, and must be unique for each account and region.</p>',
    )


class ChannelInfo(BaseModel):
    ChannelARN: Optional[ResourceARN] = None
    ChannelName_1: Optional[ChannelName] = Field(None, alias='ChannelName')
    ChannelStatus: Optional[Status] = None
    ChannelType_1: Optional[ChannelType] = Field(None, alias='ChannelType')
    CreationTime: Optional[Timestamp] = None
    SingleMasterConfiguration_1: Optional[SingleMasterConfiguration] = Field(
        None, alias='SingleMasterConfiguration'
    )
    Version_1: Optional[Version] = Field(None, alias='Version')


class ChannelInfoList(RootModel[List[ChannelInfo]]):
    root: List[ChannelInfo]


class CreateSignalingChannelOutput(BaseModel):
    ChannelARN: Optional[ResourceARN] = None


class CreateStreamOutput(BaseModel):
    StreamARN: Optional[ResourceARN] = None


class DeleteSignalingChannelInput(BaseModel):
    ChannelARN: ResourceARN
    CurrentVersion: Optional[Version] = None


class DeleteStreamInput(BaseModel):
    CurrentVersion: Optional[Version] = None
    StreamARN: ResourceARN


class DescribeEdgeConfigurationInput(BaseModel):
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class DescribeImageGenerationConfigurationInput(BaseModel):
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class DescribeMappedResourceConfigurationInput(BaseModel):
    MaxResults: Optional[MappedResourceConfigurationListLimit] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class DescribeMediaStorageConfigurationInput(BaseModel):
    ChannelARN: Optional[ResourceARN] = None
    ChannelName_1: Optional[ChannelName] = Field(None, alias='ChannelName')


class DescribeNotificationConfigurationInput(BaseModel):
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class DescribeSignalingChannelInput(BaseModel):
    ChannelARN: Optional[ResourceARN] = None
    ChannelName_1: Optional[ChannelName] = Field(None, alias='ChannelName')


class DescribeSignalingChannelOutput(BaseModel):
    ChannelInfo_1: Optional[ChannelInfo] = Field(None, alias='ChannelInfo')


class DescribeStreamInput(BaseModel):
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class FormatConfig(RootModel[Optional[Dict[str, FormatConfigValue]]]):
    root: Optional[Dict[str, FormatConfigValue]] = None


class GetDataEndpointInput(BaseModel):
    APIName_1: APIName = Field(..., alias='APIName')
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class GetSignalingChannelEndpointInput(BaseModel):
    ChannelARN: ResourceARN
    SingleMasterChannelEndpointConfiguration_1: Optional[
        SingleMasterChannelEndpointConfiguration
    ] = Field(None, alias='SingleMasterChannelEndpointConfiguration')


class ImageGenerationConfiguration(BaseModel):
    DestinationConfig: ImageGenerationDestinationConfig
    Format_1: Format = Field(..., alias='Format')
    FormatConfig_1: Optional[FormatConfig] = Field(None, alias='FormatConfig')
    HeightPixels_1: Optional[HeightPixels] = Field(None, alias='HeightPixels')
    ImageSelectorType_1: ImageSelectorType = Field(..., alias='ImageSelectorType')
    SamplingInterval_1: SamplingInterval = Field(..., alias='SamplingInterval')
    Status: ConfigurationStatus
    WidthPixels_1: Optional[WidthPixels] = Field(None, alias='WidthPixels')


class ListSignalingChannelsInput(BaseModel):
    ChannelNameCondition_1: Optional[ChannelNameCondition] = Field(
        None, alias='ChannelNameCondition'
    )
    MaxResults: Optional[ListStreamsInputLimit] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListSignalingChannelsOutput(BaseModel):
    ChannelInfoList_1: Optional[ChannelInfoList] = Field(None, alias='ChannelInfoList')
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListStreamsInput(BaseModel):
    MaxResults: Optional[ListStreamsInputLimit] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    StreamNameCondition_1: Optional[StreamNameCondition] = Field(
        None, alias='StreamNameCondition'
    )


class ListTagsForResourceInput(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ResourceARN_1: ResourceARN = Field(..., alias='ResourceARN')


class ListTagsForStreamInput(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class LocalSizeConfig(BaseModel):
    MaxLocalMediaSizeInMB_1: Optional[MaxLocalMediaSizeInMB] = Field(
        None, alias='MaxLocalMediaSizeInMB'
    )
    StrategyOnFullSize_1: Optional[StrategyOnFullSize] = Field(
        None, alias='StrategyOnFullSize'
    )


class MappedResourceConfigurationListItem(BaseModel):
    ARN: Optional[ResourceARN] = None
    Type_1: Optional[Type] = Field(None, alias='Type')


class MediaSourceConfig(BaseModel):
    MediaUriSecretArn_1: MediaUriSecretArn = Field(..., alias='MediaUriSecretArn')
    MediaUriType_1: MediaUriType = Field(..., alias='MediaUriType')


class MediaStorageConfiguration(BaseModel):
    Status: MediaStorageConfigurationStatus
    StreamARN: Optional[ResourceARN] = None


class NotificationConfiguration(BaseModel):
    DestinationConfig: NotificationDestinationConfig
    Status: ConfigurationStatus


class ResourceEndpointList(RootModel[List[ResourceEndpointListItem]]):
    root: List[ResourceEndpointListItem]


class ResourceTags(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class ScheduleConfig(BaseModel):
    DurationInSeconds_1: DurationInSeconds = Field(..., alias='DurationInSeconds')
    ScheduleExpression_1: ScheduleExpression = Field(..., alias='ScheduleExpression')


class StreamInfo(BaseModel):
    CreationTime: Optional[Timestamp] = None
    DataRetentionInHours_1: Optional[DataRetentionInHours] = Field(
        None, alias='DataRetentionInHours'
    )
    DeviceName_1: Optional[DeviceName] = Field(None, alias='DeviceName')
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    MediaType_1: Optional[MediaType] = Field(None, alias='MediaType')
    Status_1: Optional[Status] = Field(None, alias='Status')
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')
    Version_1: Optional[Version] = Field(None, alias='Version')


class StreamInfoList(RootModel[List[StreamInfo]]):
    root: List[StreamInfo]


class Tag(BaseModel):
    Key: TagKey
    Value: TagValue


class TagList(RootModel[List[Tag]]):
    root: List[Tag] = Field(..., max_length=50, min_length=1)


class TagOnCreateList(RootModel[List[Tag]]):
    root: List[Tag] = Field(..., max_length=50, min_length=0)


class TagResourceInput(BaseModel):
    ResourceARN_1: ResourceARN = Field(..., alias='ResourceARN')
    Tags: TagList


class TagStreamInput(BaseModel):
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')
    Tags: ResourceTags


class UpdateDataRetentionInput(BaseModel):
    CurrentVersion: Version
    DataRetentionChangeInHours_1: DataRetentionChangeInHours = Field(
        ..., alias='DataRetentionChangeInHours'
    )
    Operation: UpdateDataRetentionOperation
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class UpdateImageGenerationConfigurationInput(BaseModel):
    ImageGenerationConfiguration_1: Optional[ImageGenerationConfiguration] = Field(
        None, alias='ImageGenerationConfiguration'
    )
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class UpdateMediaStorageConfigurationInput(BaseModel):
    ChannelARN: ResourceARN
    MediaStorageConfiguration_1: MediaStorageConfiguration = Field(
        ..., alias='MediaStorageConfiguration'
    )


class UpdateNotificationConfigurationInput(BaseModel):
    NotificationConfiguration_1: Optional[NotificationConfiguration] = Field(
        None, alias='NotificationConfiguration'
    )
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class UpdateSignalingChannelInput(BaseModel):
    ChannelARN: ResourceARN
    CurrentVersion: Version
    SingleMasterConfiguration_1: Optional[SingleMasterConfiguration] = Field(
        None, alias='SingleMasterConfiguration'
    )


class UpdateStreamInput(BaseModel):
    CurrentVersion: Version
    DeviceName_1: Optional[DeviceName] = Field(None, alias='DeviceName')
    MediaType_1: Optional[MediaType] = Field(None, alias='MediaType')
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class UploaderConfig(BaseModel):
    ScheduleConfig_1: ScheduleConfig = Field(..., alias='ScheduleConfig')


class TagResourcePostRequest(BaseModel):
    ResourceARN: constr(
        pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
        min_length=1,
        max_length=1024,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the signaling channel to which you want to add tags.',
    )
    Tags: List[Tag] = Field(
        ...,
        description='A list of tags to associate with the specified signaling channel. Each tag is a key-value pair.',
        max_length=50,
        min_length=1,
    )


class CreateSignalingChannelPostRequest(BaseModel):
    ChannelName: constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256) = (
        Field(
            ...,
            description='A name for the signaling channel that you are creating. It must be unique for each Amazon Web Services account and Amazon Web Services Region.',
        )
    )
    ChannelType_1: Optional[ChannelType] = Field(
        None,
        alias='ChannelType',
        description='A type of the signaling channel that you are creating. Currently, <code>SINGLE_MASTER</code> is the only supported channel type. ',
    )
    SingleMasterConfiguration_1: Optional[SingleMasterConfiguration] = Field(
        None,
        alias='SingleMasterConfiguration',
        description='A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel type.',
    )
    Tags: Optional[List[Tag]] = Field(
        None,
        description='A set of tags (key-value pairs) that you want to associate with this channel.',
        max_length=50,
        min_length=0,
    )


class ImageGenerationConfiguration1(BaseModel):
    DestinationConfig: Optional[ImageGenerationDestinationConfig] = None
    Format_1: Optional[Format] = Field(None, alias='Format')
    FormatConfig_1: Optional[FormatConfig] = Field(None, alias='FormatConfig')
    HeightPixels_1: Optional[HeightPixels] = Field(None, alias='HeightPixels')
    ImageSelectorType_1: Optional[ImageSelectorType] = Field(
        None, alias='ImageSelectorType'
    )
    SamplingInterval_1: Optional[SamplingInterval] = Field(
        None, alias='SamplingInterval'
    )
    Status: Optional[ConfigurationStatus] = None
    WidthPixels_1: Optional[WidthPixels] = Field(None, alias='WidthPixels')


class UpdateImageGenerationConfigurationPostRequest(BaseModel):
    ImageGenerationConfiguration: Optional[ImageGenerationConfiguration1] = Field(
        None,
        description='The structure that contains the information required for the KVS images delivery. If null, the configuration will be deleted from the stream.',
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the image generation configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream from which to update the image generation configuration. You must specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )


class CreateSignalingChannelInput(BaseModel):
    ChannelName_1: ChannelName = Field(..., alias='ChannelName')
    ChannelType_1: Optional[ChannelType] = Field(None, alias='ChannelType')
    SingleMasterConfiguration_1: Optional[SingleMasterConfiguration] = Field(
        None, alias='SingleMasterConfiguration'
    )
    Tags: Optional[TagOnCreateList] = None


class CreateStreamInput(BaseModel):
    DataRetentionInHours_1: Optional[DataRetentionInHours] = Field(
        None, alias='DataRetentionInHours'
    )
    DeviceName_1: Optional[DeviceName] = Field(None, alias='DeviceName')
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    MediaType_1: Optional[MediaType] = Field(None, alias='MediaType')
    StreamName_1: StreamName = Field(..., alias='StreamName')
    Tags: Optional[ResourceTags] = None


class DeletionConfig(BaseModel):
    DeleteAfterUpload_1: Optional[DeleteAfterUpload] = Field(
        None, alias='DeleteAfterUpload'
    )
    EdgeRetentionInHours_1: Optional[EdgeRetentionInHours] = Field(
        None, alias='EdgeRetentionInHours'
    )
    LocalSizeConfig_1: Optional[LocalSizeConfig] = Field(None, alias='LocalSizeConfig')


class DescribeImageGenerationConfigurationOutput(BaseModel):
    ImageGenerationConfiguration_1: Optional[ImageGenerationConfiguration] = Field(
        None, alias='ImageGenerationConfiguration'
    )


class DescribeMediaStorageConfigurationOutput(BaseModel):
    MediaStorageConfiguration_1: Optional[MediaStorageConfiguration] = Field(
        None, alias='MediaStorageConfiguration'
    )


class DescribeNotificationConfigurationOutput(BaseModel):
    NotificationConfiguration_1: Optional[NotificationConfiguration] = Field(
        None, alias='NotificationConfiguration'
    )


class DescribeStreamOutput(BaseModel):
    StreamInfo_1: Optional[StreamInfo] = Field(None, alias='StreamInfo')


class GetSignalingChannelEndpointOutput(BaseModel):
    ResourceEndpointList_1: Optional[ResourceEndpointList] = Field(
        None, alias='ResourceEndpointList'
    )


class ListStreamsOutput(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    StreamInfoList_1: Optional[StreamInfoList] = Field(None, alias='StreamInfoList')


class ListTagsForResourceOutput(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    Tags: Optional[ResourceTags] = None


class ListTagsForStreamOutput(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    Tags: Optional[ResourceTags] = None


class MappedResourceConfigurationList(
    RootModel[List[MappedResourceConfigurationListItem]]
):
    root: List[MappedResourceConfigurationListItem] = Field(
        ..., max_length=1, min_length=0
    )


class RecorderConfig(BaseModel):
    MediaSourceConfig_1: MediaSourceConfig = Field(..., alias='MediaSourceConfig')
    ScheduleConfig_1: Optional[ScheduleConfig] = Field(None, alias='ScheduleConfig')


class EdgeConfig1(BaseModel):
    DeletionConfig_1: Optional[DeletionConfig] = Field(None, alias='DeletionConfig')
    HubDeviceArn_1: Optional[HubDeviceArn] = Field(None, alias='HubDeviceArn')
    RecorderConfig_1: Optional[RecorderConfig] = Field(None, alias='RecorderConfig')
    UploaderConfig_1: Optional[UploaderConfig] = Field(None, alias='UploaderConfig')


class StartEdgeConfigurationUpdatePostRequest(BaseModel):
    EdgeConfig: EdgeConfig1 = Field(
        ...,
        description="A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.",
    )
    StreamARN: Optional[
        constr(
            pattern=r'arn:[a-z\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+',
            min_length=1,
            max_length=1024,
        )
    ] = Field(
        None,
        description=' The Amazon Resource Name (ARN) of the stream. Specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )
    StreamName: Optional[
        constr(pattern=r'[a-zA-Z0-9_.-]+', min_length=1, max_length=256)
    ] = Field(
        None,
        description='The name of the stream whose edge configuration you want to update. Specify either the <code>StreamName</code> or the <code>StreamARN</code>.',
    )


class DescribeMappedResourceConfigurationOutput(BaseModel):
    MappedResourceConfigurationList_1: Optional[MappedResourceConfigurationList] = (
        Field(None, alias='MappedResourceConfigurationList')
    )
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class EdgeConfig(BaseModel):
    DeletionConfig_1: Optional[DeletionConfig] = Field(None, alias='DeletionConfig')
    HubDeviceArn_1: HubDeviceArn = Field(..., alias='HubDeviceArn')
    RecorderConfig_1: RecorderConfig = Field(..., alias='RecorderConfig')
    UploaderConfig_1: Optional[UploaderConfig] = Field(None, alias='UploaderConfig')


class StartEdgeConfigurationUpdateInput(BaseModel):
    EdgeConfig_1: EdgeConfig = Field(..., alias='EdgeConfig')
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')


class StartEdgeConfigurationUpdateOutput(BaseModel):
    CreationTime: Optional[Timestamp] = None
    EdgeConfig_1: Optional[EdgeConfig] = Field(None, alias='EdgeConfig')
    FailedStatusDetails_1: Optional[FailedStatusDetails] = Field(
        None, alias='FailedStatusDetails'
    )
    LastUpdatedTime: Optional[Timestamp] = None
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')
    SyncStatus_1: Optional[SyncStatus] = Field(None, alias='SyncStatus')


class DescribeEdgeConfigurationOutput(BaseModel):
    CreationTime: Optional[Timestamp] = None
    EdgeConfig_1: Optional[EdgeConfig] = Field(None, alias='EdgeConfig')
    FailedStatusDetails_1: Optional[FailedStatusDetails] = Field(
        None, alias='FailedStatusDetails'
    )
    LastUpdatedTime: Optional[Timestamp] = None
    StreamARN: Optional[ResourceARN] = None
    StreamName_1: Optional[StreamName] = Field(None, alias='StreamName')
    SyncStatus_1: Optional[SyncStatus] = Field(None, alias='SyncStatus')
